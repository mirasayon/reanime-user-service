generator client {
  provider               = "prisma-client"
  output                 = "../../src/databases/orm"
  runtime                = "nodejs"
  moduleFormat           = "esm"
  generatedFileExtension = "ts"
  importFileExtension    = "js"
  engineType             = "client"
}

datasource db {
  provider = "postgresql"
}

model Account {
  id         String   @id @default(cuid())
  created_at DateTime @default(now()) @db.Timestamptz
  updated_at DateTime @updatedAt @db.Timestamptz

  // Role/type of account (common, banned, admin, etc.)
  type                 AccountTypeEnum @default(COMMON)
  email                String?         @unique
  username             String          @unique
  password_hash        String
  password_version     Int             @default(1) /// 1 = bcrypt
  last_password_change DateTime?
  is_activated         Boolean         @default(false)
  activation_link      String?

  profile  Profile?
  sessions Session[]

  @@index([type])
  @@index([is_activated])
  @@index([activation_link])
}

model Session {
  id           String    @id @default(cuid())
  token_hash   String    @unique @db.VarChar(128)
  created_at   DateTime  @default(now()) @db.Timestamptz
  updated_at   DateTime  @updatedAt @db.Timestamptz
  expires_at   DateTime  @db.Timestamptz
  last_used_at DateTime? @db.Timestamptz

  /// Network / location
  ip_address          String? // raw IP (consider masking / hashing for privacy)
  ip_country          String? // ISO country code or full name
  ip_region           String? // region / state
  ip_city             String?
  location_updated_at DateTime? @db.Timestamptz

  /// `User-Agent` header string
  user_agent     String?
  /// "console" | "desktop" | "embedded" | "mobile" | "smarttv" | "tablet" | "wearable" | "xr";
  device_type    String?
  /// device model
  deviceModel    String?
  /// OS Name
  os             String?
  /// OS Version
  osVersion      String?
  /// Browser name
  browser        String?
  /// Browser version
  browserVersion String?
  /// hashed fingerprint for deduping devices
  device_hash    String?

  // Relation
  by_account    Account @relation(fields: [by_account_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  by_account_id String

  // Indexes
  @@index([by_account_id])
  @@index([ip_address])
  @@index([device_hash])
  @@index([ip_country, ip_region])
  @@index([expires_at])
}

model AvatarPicture {
  id            String   @id @default(cuid())
  created_at    DateTime @default(now()) @db.Timestamptz
  updated_at    DateTime @updatedAt @db.Timestamptz
  url           String
  by_profile    Profile  @relation(fields: [by_profile_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  by_profile_id String   @unique
}

model ProfileCoverPicture {
  id            String   @id @default(cuid())
  created_at    DateTime @default(now()) @db.Timestamptz
  updated_at    DateTime @updatedAt @db.Timestamptz
  url           String
  by_profile    Profile  @relation(fields: [by_profile_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  by_profile_id String   @unique
}

model Profile {
  id            String               @id @default(cuid())
  created_at    DateTime             @default(now()) @db.Timestamptz
  updated_at    DateTime             @updatedAt @db.Timestamptz
  avatar        AvatarPicture?
  cover         ProfileCoverPicture?
  bio           String?
  by_account    Account              @relation(fields: [by_account_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  by_account_id String               @unique
  nickname      String?

  // date of birth
  date_of_birth        DateTime?               @db.Date
  birthdate_visibility BirthdateVisibilityEnum @default(NONE)
  comments             Comment[]
  replies_to_comment   ReplyToComment[]
  reply_votes          ReplyVote[]
  comment_votes        CommentVote[]

  gender            GenderEnum?          @default(UNSPECIFIED) // ‚Üê –¥–æ–±–∞–≤–ª–µ–Ω–æ üëá
  gender_visibility GenderVisibilityEnum @default(NONE) // —Ö–æ—á–µ—à—å ‚Äî –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ visibility
  anime_votes       AnimeFavorite[]
  // Anime list entries
  anime_bookmarks   AnimeBookmark[]
}

/// Bookmarks for user's anime list. Unique per profile+anime.
model AnimeBookmark {
  id         String   @id @default(cuid())
  created_at DateTime @default(now()) @db.Timestamptz
  updated_at DateTime @updatedAt @db.Timestamptz

  profile    Profile         @relation(fields: [profile_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  profile_id String
  anime_id   Int             @db.Integer
  status     AnimeStatusEnum

  @@unique([profile_id, anime_id])
  @@index([profile_id])
  @@index([anime_id])
  @@index([status])
}

/// Favorite (like) for an anime. vote = true means liked.
model AnimeFavorite {
  id         String   @id @default(cuid())
  created_at DateTime @default(now()) @db.Timestamptz
  updated_at DateTime @updatedAt @db.Timestamptz

  profile    Profile @relation(fields: [profile_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  profile_id String
  anime_id   Int     @db.Integer
  vote       Boolean

  @@unique([profile_id, anime_id])
  @@index([profile_id])
  @@index([anime_id])
  @@index([vote])
}

/// Reply to a comment.
model ReplyToComment {
  id         String   @id @default(cuid())
  created_at DateTime @default(now()) @db.Timestamptz
  updated_at DateTime @updatedAt @db.Timestamptz

  content       String  @db.Text
  by_profile    Profile @relation(fields: [by_profile_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  by_profile_id String

  is_visible    Boolean @default(true)
  to_comment    Comment @relation(fields: [to_comment_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  to_comment_id String

  ratings ReplyVote[]

  @@index([by_profile_id])
  @@index([to_comment_id])
}

/// Comment model for anime comments.
model Comment {
  id         String   @id @default(cuid())
  created_at DateTime @default(now()) @db.Timestamptz
  updated_at DateTime @updatedAt @db.Timestamptz
  content    String   @db.Text
  is_visible Boolean  @default(true)

  by_profile    Profile          @relation(fields: [by_profile_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  by_profile_id String
  anime_id      Int              @db.Integer
  ratings       CommentVote[]
  replies       ReplyToComment[]

  @@index([anime_id])
}

/// Vote on comment (unique per profile + comment).
model CommentVote {
  id         String   @id @default(cuid())
  created_at DateTime @default(now()) @db.Timestamptz
  updated_at DateTime @updatedAt @db.Timestamptz

  by_profile    Profile @relation(fields: [by_profile_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  by_profile_id String

  comment    Comment @relation(fields: [comment_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  comment_id String
  vote       Boolean

  @@unique([by_profile_id, comment_id])
  @@index([comment_id])
  @@index([by_profile_id])
}

/// Vote on reply (unique per profile + reply).
model ReplyVote {
  id         String   @id @default(cuid())
  created_at DateTime @default(now()) @db.Timestamptz
  updated_at DateTime @updatedAt @db.Timestamptz

  by_profile    Profile        @relation(fields: [by_profile_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  by_profile_id String
  reply         ReplyToComment @relation(fields: [reply_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  reply_id      String
  vote          Boolean

  @@unique([by_profile_id, reply_id])
  @@index([reply_id])
  @@index([by_profile_id])
}

/// Visibility options for birthdate
enum BirthdateVisibilityEnum {
  NONE // —Å–∫—Ä—ã—Ç–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é
  YEAR_ONLY /// –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –≥–æ–¥
  FULL // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª–Ω—É—é –¥–∞—Ç—É
}

/// Visibility options for gender
enum GenderVisibilityEnum {
  NONE
  PUBLIC
}

/// Gender enum
enum GenderEnum {
  MALE
  FEMALE
  // —É–≤–∞–∂–∏—Ç–µ–ª—å–Ω–æ –¥–ª—è —Ç–µ—Ö, –∫—Ç–æ –Ω–µ –≤–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –≤ –±–∏–Ω–∞—Ä–Ω—É—é —Å–∏—Å—Ç–µ–º—É
  OTHER
  // –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (—é–∑–µ—Ä –Ω–µ –≤—ã–±—Ä–∞–ª)
  UNSPECIFIED
}

/// Anime status in bookmark
enum AnimeStatusEnum {
  WATCHING
  ABANDONED
  PLANNED
  COMPLETED
}

/// Account types / roles
enum AccountTypeEnum {
  COMMON
  BANNED
  ADMIN
  DEVELOPER
  TESTER
}
